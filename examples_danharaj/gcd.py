import sympy as sym
from sympy.core.numbers import igcd, igcdex
import random
import numpy as np
import pdb

from qagen.qagen import *
from qagen import utils
from qagen import unit_test_for_user as user_test

# The name of the class can be arbitrary but should be suggestive
class QA_gcd(QAGen):
    def __init__(self):
        super().__init__()
        # Set some descriptive information about the QA problem
        # The author should be you
        # The description should be an instance of a question your code can
        # generate
        # The keywords should suggest what sort of domain this problem
        # belongs to
        self.author = 'Dan Haraj'
        # This example problem is for finding the greatest common divisor
        # of two numbers and also the coefficients that make bezout's identity
        # hold.
        self.description = (
            "Given integers a = 15 , b = 20 , find their greatest common divisor"
            " which is the smallest positive"
            " integer d for which there exist integers x , y such that"
            " a x + b y = d .")
        # This problem falls under both algebra and number theory
        self.keywords = ['algebra', 'number theory']

    def seed_all (self, seed):
        # In this function you should initialize all the random number
        # generators your code uses. random is the standard random number
        # package. np.random is the random number generator that numpy uses
        # and fake.random is used by the faker package.
        #
        # You might not need all of these and you might need more of them
        # if you use further other packages.
        random.seed(seed)
        np.random.seed(seed)
        self.fake.random.seed(seed)

    def init_consistent_qa_variables (self):
        # Some variables are shared between the question and the answer.
        # This function should initialize these.
        #
        # In this example our questions mention 5 variables.
        if self.debug:
            # These variables should be set to the ones that are used in your
            # problem instance as given in the description.
            #
            # For this code example our example question uses the variable
            # names 'a', 'b', 'd', 'x' and 'y'.
            a, b, d, x, y = symbols('a b d x y')
        else:
            # otherwise you should initialize the symbols to random names.
            # the framework will make sure that generated pairs of questions
            # and answers share these variables.
            #
            # In this example we use 5 distinct variables.
            a, b, d, x, y = self.get_symbols(5)
        return a, b, d, x, y

    def init_qa_variables(self):
        # Define parameters of the question answer pair here. In this example
        # the questions are parameterized by the values of the integers whose
        # GCD we are asking for.
        #
        # The parameters will be different for your questions.
        if self.debug:
            # These values should correspond to the parameters of the question
            # given in the description.
            a_val = 15
            b_val = 20
        else:
            # Otherwise generate parameters that are reasonable for your
            # question.
            a_val, b_val = tuple(np.random.randint(2,100, [2]))
        return a_val, b_val

    def Q(s, a_val, b_val, a, b, d, x, y):
        # This method takes as arguments the parameters and the variables
        # generated by the methods above and uses them to generate a question.

        # These are some helper functions for formatting and generating a
        # question. `seqg` is a function that concatenates strings and symbolic
        # equations together. `perg` takes a sequence of strings and equations
        # and returns a random permutation of them. `choiceg` takes a sequence
        # of strings and equations and outputs only one of them.
        seqg, perg, choiceg = s.seqg, s.perg, s.choiceg

        # In this code example the order in which we list the variables and
        # their values does not change the question, so we can permute that
        # part.
        #
        # If you use permutable pieces in your question instance you should
        # list the pieces in the order your description problem lists them.
        #
        # This is because the framework uses the identity permutation when
        # trying to reproduce your description question as a sanity check.
        permutable_part = perg(seqg(sym.Eq(a, a_val), ',')
                               , seqg(sym.Eq(b, b_val), ','))

        # Here we word our problem in two different ways. We use `seqg` to
        # concatenate strings and equations to create a problem instance.
        # At least one of your question variants should be able to generate
        # the question in your description.
        q1 = seqg("Given integers"
               , permutable_part
               , "find their greatest common divisor which is the smallest"
               , "positive integer"
               , d
               , "for which there exist integers"
               , x, ",", y
               , "such that", sym.Eq(a*x + b*y, d), ".")
        q2 = seqg ("If", a, ",", b
               , "are integers then there exist"
               , d, ",", x, ",", y
               , "such that", d, "is the smallest positive integer such that"
               , sym.Eq(a*x + b*y, d), "."
               , "if", permutable_part, "solve for", d, ",", x, ",", y, ".")
        # We return a random choice between our question alternatives. It is
        # ideal to have at least 2 or 3 alternatives. You should list the
        # alternative first that can be instantiated to your description
        # question because the framework will choose the first item in every
        # call of choiceg when trying to reproduce your description question.
        return choiceg(q1, q2)

    def A(s, a_val, b_val, a, b, d, x, y):
        # In this method you should generate an answer based on the particular
        # parameters and variable names generated for this QA instance.
        # It is ideal to rely on sympy and other libraries to do the solving
        # for you.
        seqg, choiceg = s.seqg, s.choiceg
        x_val, y_val, d_val = igcdex(a_val, b_val)
        a1 = seqg(sym.Eq(d, d_val), sym.Eq(x, x_val), sym.Eq(y, y_val))
        a2 = seqg("The greatest common divisor of"
               , a, "and", b, "is", sym.Eq(d,d_val)
               , "with coefficients", sym.Eq(x, x_val), sym.Eq(y, y_val))
        # try to generate at least 2 or 3 different wordings of the answer.
        return choiceg(a1, a2)

    def get_qa(self,seed):
        # This function illustrates how the framework can be used to generate
        # a question/answer pair from your instance. This sort of function
        # is useful to define for debugging purposes.
        self.seed_all(seed)
        # get variables for qa and register them for the current q,a
        variables, variables_consistent = self._create_all_variables()
        # get concrete qa strings
        q_str = self.Q(*variables,*variables_consistent)
        a_str = self.A(*variables,*variables_consistent)
        return q_str, a_str

# your module should include a code block like this so that when it is run
# as a script it automatically runs some standard unit tests that will check
# that your implementation is sufficiently coherent and robust.
if __name__ == '__main__':
    user_test.run_unit_test_for_user(QA_gcd)
